
論理関数に関する処理
====================

論理値(Bool3)
-------------

論理値は `lctools.Bool3` を用いて表す．
本来，論理値は真と偽の2値であるが，
`lctools` では不完全指定論理関数を扱うために
ドントケアを含めた3値を扱う必要があるために
専用の列挙型として `Bool3` を用いる．

.. table::
   :align: left
   :widths: auto

   ===== ===========
   値    意味
   ===== ===========
   _0    偽(0)
   _1    真(1)
   _d    ドントケア
   ===== ===========

`Bool3` に関しては Python3 の組み込み型の
bool 型と同様に以下の論理演算をサポートしている．

.. table::
   :align: left
   :widths: auto

   ====== ============ ===================
   演算子 関数         意味
   ====== ============ ===================
   ~      __invert__   否定
   &      __and__      論理積
   |      __or__       論理和
   ^      __xor__      排他的論理和
   <      __lt__       小なり比較
   >      __gt__       大なり比較
   <=     __le__       小なりイコール比較
   >=     __ge__       小なりイコール比較
   ====== ============ ===================


論理関数(BoolFunc)
------------------

論理関数を表すには `lctools.BoolFunc` を用いる．
`BoolFunc` は内部では2^n個の `Bool3` を持つ(nは入力数)．
多くの入力を持つ関数を扱うことはできない．


BoolFuncの生成
^^^^^^^^^^^^^^

BoolFunc のオブジェクト単純に生成にするには以下の形式を用いる．

::

   n = 2

   list1 = [Bool3._0, Bool3._1, Bool3._1, Bool3._0]
   f1 = BoolFunc(n, val_list=list1)

   str2 = "0110"
   f2 = BoolFunc(n, val_str=str2)

この場合， `f1` も `f2` も2入力の排他的論理和(XOR)を表す論理関数となる．
`BoolFunc` は必ず1つの位置引数(上の例では `n` )を取る．
この引数の値が生成される論理関数の入力数となる．
それ以外の引数は名前付きオプション引数である．
例から明らかなように `val_list` には生成する関数の内容を表す
`Bool3` のリストを与える．
`val_str` には生成する関数の内容を表す文字列を与える．
この文字列で用いられる文字は 0, 1, *, -, d のいずれかである．
このうち 0 と 1 以外の文字はドントケアを表す．
`val_list` も `val_str` も要素数は2^nに等しくなければならない．
`val_list` と `val_str` のオプション引数は2つ同時に指定することはできない．
`BoolFunc` には3番目のオプション引数`var_map`を指定することもできる．
`var_map` には整数値をキーとして文字列を値としたdictを与える．
その名前から推測されるように `var_map` は変数名を与える目的で用いられる．
論理関数にとって変数は順番のみが意味を持ち，
論理関数の演算にとっては変数名は意味を持たないが，
関数の内容を出力する際に用いられる．
ただし，論理関数を出力する際に別の変数名の辞書を与えることも可能である．

`BoolFunc` の内容は生成時以外には変更することはできない．
そのため，いかなる場合でも直接的・間接的に上記の初期化関数を用いる以外に
`BoolFunc` の内容を設定することはできない．
しかし，上記の初期化関数では関数の真理値表形式を表現を作る必要があり，
複雑な関数を作る場合には適切なインターフェイスとは言えない．
そこで，いくつかの便利関数として`BoolFunc`のクラス関数(Pythonの@staticmethod)
を用意している．

.. table::
   :align: left
   :widths: auto

   =============================== ========================
   関数名                          説明
   =============================== ========================
   make_const0(input_num)          定数0関数を作る．
   make_const1(input_num)          定数1関数を作る．
   make_literal(input_num, var_id) リテラル関数を作る．
   make_and(input_num)             AND関数を作る．
   make_nand(input_num)            NAND関数を作る．
   make_or(input_num)              OR関数を作る．
   make_nor(input_num)             NOR関数を作る．
   make_xor(input_num)             XOR関数を作る．
   make_xnor(input_num)            XNOR関数を作る．
   =============================== ========================

上記の関数はすべてオプション引数として `var_map` を受け取ることもできる．
意味は初期化関数と同一である．
共通の位置引数 `input_num` には生成する関数の入力数を与える．
`BoolFunc.make_literal(input_num, var_id)` は `var_id`
の変数が1のとき出力が1となるリテラル関数を生成する．
もしも否定のリテラル関数が必要な場合には，
この結果に否定演算子を適用すればよい．

より複雑な関数を作る手段としてさらにいくつかの関数が用意されている．
その一つはクラス関数 `make_fron_string(expr_string, input_num, var_map)`
である． `expr_string` には論理式を表す文字列を与え，
`input_num` ，`var_map` にそれぞれ入力数と変数名の辞書を与える．
他の関数とは異なり，この関数では変数名の辞書は必須の引数となっている．

もう一つの方法は `BoolFunc` オブジェクトに対して論理演算を適用して新しい
論理関数を生成するものである．
`BoolFunc` の特殊メソッドとして通常の論理演算と同様の演算子が定義されている．
これらはすべて `BoolFunc` を入力として `BoolFunc` を結果として出力する．
この論理演算子を組み合わせることで，通常のPythonの式の形で論理関数を生
成することが可能である．詳細は論理演算の項を参照の事．

論理演算
^^^^^^^^
