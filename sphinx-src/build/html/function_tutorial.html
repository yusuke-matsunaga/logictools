
<!DOCTYPE html>

<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>論理関数に関する処理 &#8212; logictools 1.0 ドキュメント</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="積和形論理式に関する処理" href="sop_tutorial.html" />
    <link rel="prev" title="LogicTools: 論理回路の学習用ツール" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="sop_tutorial.html" title="積和形論理式に関する処理"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="index.html" title="LogicTools: 論理回路の学習用ツール"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">logictools 1.0 ドキュメント</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">論理関数に関する処理</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="id1">
<h1>論理関数に関する処理<a class="headerlink" href="#id1" title="この見出しへのパーマリンク">¶</a></h1>
<section id="bool3">
<h2>論理値(Bool3)<a class="headerlink" href="#bool3" title="この見出しへのパーマリンク">¶</a></h2>
<p>論理値は <cite>lctools.Bool3</cite> を用いて表す．
本来，論理値は真と偽の2値であるが，
<cite>lctools</cite> では不完全指定論理関数を扱うために
ドントケアを含めた3値を扱う必要があるので
専用の列挙型として <cite>Bool3</cite> を用いる．</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>値</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>_0</p></td>
<td><p>偽(0)</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>真(1)</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>ドントケア</p></td>
</tr>
</tbody>
</table>
<p><cite>Bool3</cite> に関しては Python3 の組み込み型の
bool 型と同様に以下の論理演算をサポートしている．</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>演算子</p></th>
<th class="head"><p>関数</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>~</p></td>
<td><p>__invert__</p></td>
<td><p>否定</p></td>
</tr>
<tr class="row-odd"><td><p>&amp;</p></td>
<td><p>__and__</p></td>
<td><p>論理積</p></td>
</tr>
<tr class="row-even"><td><p>|</p></td>
<td><p>__or__</p></td>
<td><p>論理和</p></td>
</tr>
<tr class="row-odd"><td><p>^</p></td>
<td><p>__xor__</p></td>
<td><p>排他的論理和</p></td>
</tr>
<tr class="row-even"><td><p>&lt;</p></td>
<td><p>__lt__</p></td>
<td><p>小なり比較</p></td>
</tr>
<tr class="row-odd"><td><p>&gt;</p></td>
<td><p>__gt__</p></td>
<td><p>大なり比較</p></td>
</tr>
<tr class="row-even"><td><p>&lt;=</p></td>
<td><p>__le__</p></td>
<td><p>小なりイコール比較</p></td>
</tr>
<tr class="row-odd"><td><p>&gt;=</p></td>
<td><p>__ge__</p></td>
<td><p>小なりイコール比較</p></td>
</tr>
</tbody>
</table>
<p>否定演算の真理値表は以下の通り</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>x</p></th>
<th class="head"><p>~x</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>_0</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
</tbody>
</table>
<p>AND演算の真理値表は以下の通り</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>x</p></th>
<th class="head"><p>y</p></th>
<th class="head"><p>x &amp; y</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>_0</p></td>
<td><p>_0</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-odd"><td><p>_0</p></td>
<td><p>_1</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-even"><td><p>_0</p></td>
<td><p>_d</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>_0</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-even"><td><p>_1</p></td>
<td><p>_1</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>_0</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-odd"><td><p>_d</p></td>
<td><p>_1</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
</tbody>
</table>
<p>OR演算の真理値表は以下の通り</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>x</p></th>
<th class="head"><p>y</p></th>
<th class="head"><p>x | y</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>_0</p></td>
<td><p>_0</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-odd"><td><p>_0</p></td>
<td><p>_1</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-even"><td><p>_0</p></td>
<td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>_0</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-even"><td><p>_1</p></td>
<td><p>_1</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>_d</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>_0</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-odd"><td><p>_d</p></td>
<td><p>_1</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
</tbody>
</table>
<p>XOR演算の真理値表は以下の通り</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>x</p></th>
<th class="head"><p>y</p></th>
<th class="head"><p>x ^ y</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>_0</p></td>
<td><p>_0</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-odd"><td><p>_0</p></td>
<td><p>_1</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-even"><td><p>_0</p></td>
<td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>_0</p></td>
<td><p>_1</p></td>
</tr>
<tr class="row-even"><td><p>_1</p></td>
<td><p>_1</p></td>
<td><p>_0</p></td>
</tr>
<tr class="row-odd"><td><p>_1</p></td>
<td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>_0</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-odd"><td><p>_d</p></td>
<td><p>_1</p></td>
<td><p>_d</p></td>
</tr>
<tr class="row-even"><td><p>_d</p></td>
<td><p>_d</p></td>
<td><p>_d</p></td>
</tr>
</tbody>
</table>
<p>もちろん，これらの論理演算はブール代数の公理を満たしている．</p>
<p>大小比較演算は本来のブール代数では定義されていないが，
ここでは便宜上 <cite>_0</cite> ， <cite>_1</cite> ， <cite>_d</cite> をそれぞれ0, 1, 2 と
みなして比較を行った結果を返す．
また，列挙型の値はハッシュ可能であるのでPythonのdict
のキーとして用いることもできる．</p>
<p>文字列および数値から Bool3 型へ変換を行う関数として
<cite>lctools.toBool3()</cite> を定義している．
受け付ける値と結果は以下の表の通り．</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>入力</p></th>
<th class="head"><p>入力の型</p></th>
<th class="head"><p>結果</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>'0'</p></td>
<td><p>str</p></td>
<td><p>Bool3._0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>int</p></td>
<td><p>Bool3._0</p></td>
</tr>
<tr class="row-even"><td><p>False</p></td>
<td><p>bool</p></td>
<td><p>Bool3._0</p></td>
</tr>
<tr class="row-odd"><td><p>'1'</p></td>
<td><p>str</p></td>
<td><p>Bool3._1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>int</p></td>
<td><p>Bool3._1</p></td>
</tr>
<tr class="row-odd"><td><p>True</p></td>
<td><p>bool</p></td>
<td><p>Bool3._1</p></td>
</tr>
<tr class="row-even"><td><p>'X'</p></td>
<td><p>str</p></td>
<td><p>Bool3._d</p></td>
</tr>
<tr class="row-odd"><td><p>'x'</p></td>
<td><p>str</p></td>
<td><p>Bool3._d</p></td>
</tr>
<tr class="row-even"><td><p>'D'</p></td>
<td><p>str</p></td>
<td><p>Bool3._d</p></td>
</tr>
<tr class="row-odd"><td><p>'d'</p></td>
<td><p>str</p></td>
<td><p>Bool3._d</p></td>
</tr>
<tr class="row-even"><td><p>'*'</p></td>
<td><p>str</p></td>
<td><p>Bool3._d</p></td>
</tr>
<tr class="row-odd"><td><p>'-'</p></td>
<td><p>str</p></td>
<td><p>Bool3._d</p></td>
</tr>
</tbody>
</table>
<p>前述の論理演算はどちらか一方でも Bool3 型であれば残りは上の表の変換ルー
ルを適用して Bool3 に変換可能であれば自動的に変換される．</p>
<p>Bool3と文字列間の演算例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Bool3</span><span class="o">.</span><span class="n">_0</span> <span class="o">&amp;</span> <span class="s1">&#39;1&#39;</span>
<span class="c1"># = Bool3._0 &amp; Bool3._1</span>
<span class="c1"># = Bool3._0</span>
</pre></div>
</div>
</section>
<section id="boolfunc">
<h2>論理関数(BoolFunc)<a class="headerlink" href="#boolfunc" title="この見出しへのパーマリンク">¶</a></h2>
<p>論理関数を表すには <cite>lctools.BoolFunc</cite> を用いる．
<cite>BoolFunc</cite> は内部では <img class="math" src="_images/math/d76f16a00dc1dd4eb18ca913e933b14079c81f2b.png" alt="2^n"/> 個の <cite>Bool3</cite>
を持つ( <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> は入力数)．
そのため，多くの入力を持つ関数を扱うことはできない．</p>
<section id="id2">
<h3>BoolFuncの生成<a class="headerlink" href="#id2" title="この見出しへのパーマリンク">¶</a></h3>
<p>BoolFunc のオブジェクト単純に生成にするには以下の形式を用いる．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bool3</span><span class="o">.</span><span class="n">_0</span><span class="p">,</span> <span class="n">Bool3</span><span class="o">.</span><span class="n">_1</span><span class="p">,</span> <span class="n">Bool3</span><span class="o">.</span><span class="n">_1</span><span class="p">,</span> <span class="n">Bool3</span><span class="o">.</span><span class="n">_0</span><span class="p">]</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span>

<span class="n">str2</span> <span class="o">=</span> <span class="s2">&quot;0110&quot;</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span>
</pre></div>
</div>
<p>この場合， <cite>f1</cite> も <cite>f2</cite> も2入力の排他的論理和(XOR)を表す論理関数となる．
<cite>f1</cite> の例では生成する関数の内容を表す <cite>Bool3</cite> のリストを与える．
<cite>f2</cite> の例では生成する関数の内容を表す文字列を与える．
この文字列で用いられる文字は <cite>Bool3</cite> に変換可能な文字でなければならない．
リストも場合も文字列の場合もどちらも要素数は <img class="math" src="_images/math/d76f16a00dc1dd4eb18ca913e933b14079c81f2b.png" alt="2^n"/>
に等しくなければならない．ここで， <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> は入力変数の数である．</p>
<p><cite>BoolFunc</cite> の内容は生成時以外には変更することはできない．
そのため，いかなる場合でも直接的・間接的に上記の初期化関数を用いる以外に
<cite>BoolFunc</cite> の内容を設定することはできない．
しかし，上記の初期化関数では関数の真理値表形式を表現を作る必要があり，
複雑な関数を作る場合には適切なインターフェイスとは言えない．
そこで，いくつかの便利関数として`BoolFunc`のクラス関数(Pythonの&#64;staticmethod)
を用意している．</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>関数名</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>make_const0(input_num)</p></td>
<td><p>定数0関数を作る．</p></td>
</tr>
<tr class="row-odd"><td><p>make_const1(input_num)</p></td>
<td><p>定数1関数を作る．</p></td>
</tr>
<tr class="row-even"><td><p>make_literal(input_num, var_id)</p></td>
<td><p>リテラル関数を作る．</p></td>
</tr>
<tr class="row-odd"><td><p>make_and(input_num)</p></td>
<td><p>AND関数を作る．</p></td>
</tr>
<tr class="row-even"><td><p>make_nand(input_num)</p></td>
<td><p>NAND関数を作る．</p></td>
</tr>
<tr class="row-odd"><td><p>make_or(input_num)</p></td>
<td><p>OR関数を作る．</p></td>
</tr>
<tr class="row-even"><td><p>make_nor(input_num)</p></td>
<td><p>NOR関数を作る．</p></td>
</tr>
<tr class="row-odd"><td><p>make_xor(input_num)</p></td>
<td><p>XOR関数を作る．</p></td>
</tr>
<tr class="row-even"><td><p>make_xnor(input_num)</p></td>
<td><p>XNOR関数を作る．</p></td>
</tr>
</tbody>
</table>
<p>共通の位置引数 <cite>input_num</cite> には生成する関数の入力数を与える．
<cite>BoolFunc.make_literal(input_num, var_id)</cite> は <cite>var_id</cite>
の変数が1のとき出力が1となるリテラル関数を生成する．
もしも否定のリテラル関数が必要な場合には，
この結果に否定演算子を適用すればよい．</p>
<p>より複雑な関数を作る手段としてさらにいくつかの関数が用意されている．</p>
<p>一つの方法は <cite>BoolFunc</cite> オブジェクトに対して論理演算を適用して新しい論理関数を生成するものである．
後述するように <cite>BoolFunc</cite> の特殊メソッドとして通常の論理演算と同様の演算子が定義されている．
これらはすべて <cite>BoolFunc</cite> を入力として <cite>BoolFunc</cite> を結果として出力する．
この論理演算子を組み合わせることで，通常のPythonの式の形で論理関数を生成することが可能である．
この方法で論理関数を生成するプログラム例を以下に示す．
詳細は論理演算の項を参照の事．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INPUT_NUM</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">x4</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">&amp;</span> <span class="n">x2</span> <span class="o">|</span> <span class="o">~</span><span class="n">x3</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">x4</span>
</pre></div>
</div>
<p>もう一つの方法はクラス関数
<cite>BoolFunc.make_from_string(expr_string, var_dict)</cite>
である．
<cite>expr_string</cite> には論理式を表す文字列を与え，
<cite>var_map</cite> にはそれぞれ変数名をキーにして変数番号を納めた辞書を与える．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expr_str</span> <span class="o">=</span> <span class="s2">&quot;x_1 &amp; x_2 | ~x_3 &amp; ~x_4&quot;</span>
<span class="n">var_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x_1&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;x_2&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;x_3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;x_4&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_from_string</span><span class="p">(</span><span class="n">expr_str</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id3">
<h3>論理演算<a class="headerlink" href="#id3" title="この見出しへのパーマリンク">¶</a></h3>
<p><cite>BoolFunc</cite> では論理演算系の特殊メソッドを定義しているため，
<cite>BoolFunc</cite> どうしの論理演算を行なうことができる．
自明なように，論理関数どうしの論理演算の結果は論理関数となる．
その内容は，個々の入力値に対する出力値( <cite>Bool3</cite> )に対して
同様の論理演算を行ったものと等しい．
例えば2つの論理関数 <img class="math" src="_images/math/92ee6de1f369c15469139e791146c7bd64847762.png" alt="f_1(x)"/> と <img class="math" src="_images/math/d9e56b9133f3e2e381f265b0591c71deabd395fb.png" alt="f_2(x)"/>
に対するAND演算(&amp;)の結果を <img class="math" src="_images/math/91451bcd556b3fb4efe455c92153f24ed21af9b5.png" alt="g(x)"/>
とすると次式が成り立つ．</p>
<div class="math">
<p><img src="_images/math/6ea51b044d6c91ab5575ba76bf693cab4c094326.png" alt="\forall x, g(x) = f_1(x) \&amp; f_2(x)"/></p>
</div><p>この式の右辺は関数 <img class="math" src="_images/math/0464a071da3203b9d565701f510a766ae52f3016.png" alt="f_1"/> と <img class="math" src="_images/math/8bba708bfd9e1df2575d817c79ab6ae0139b20c6.png" alt="f_2"/>
の間で演算を行っているのではなく，
論理値 <img class="math" src="_images/math/92ee6de1f369c15469139e791146c7bd64847762.png" alt="f_1(x)"/> と <img class="math" src="_images/math/d9e56b9133f3e2e381f265b0591c71deabd395fb.png" alt="f_2(x)"/>
の間で演算を行っていることに注意．</p>
<p>このように論理値( <cite>Bool3</cite> )上で定義された演算を使って，
論理関数( <cite>BoolFunc</cite> )上の演算を定義することができる．
そこで，以下のような論理演算が定義されている．</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>演算子</p></th>
<th class="head"><p>関数</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>~</p></td>
<td><p>__invert__</p></td>
<td><p>否定</p></td>
</tr>
<tr class="row-odd"><td><p>&amp;</p></td>
<td><p>__and__</p></td>
<td><p>論理積</p></td>
</tr>
<tr class="row-even"><td><p>|</p></td>
<td><p>__or__</p></td>
<td><p>論理和</p></td>
</tr>
<tr class="row-odd"><td><p>^</p></td>
<td><p>__xor__</p></td>
<td><p>排他的論理和</p></td>
</tr>
</tbody>
</table>
<p>このうち，論理否定(~)は単項演算であるため，
どのような <cite>BoolFunc</cite> オブジェクトに対しても正しく動く．
一方残りの演算子は二項演算なので，
オペランドの2つのオブジェクトがともに <cite>BoolFunc</cite> である必要がある．
さらに，2つの論理関数の入力数が等しくなければならない．</p>
<p>また，2つの関数が等しいかの比較を行なう <cite>==</cite> 演算子も定義されている．
もちろん，オブジェクトとして同一かどうかではなく，
関数の内容が等価かどうかを調べる．</p>
<p>論理演算を行なう特別な関数として <cite>compose</cite> が用意されている．
これはもとの関数の入力変数を他の論理関数に置き換えるものである．
例を示す．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lctools</span> <span class="kn">import</span> <span class="n">BoolFunc</span>

<span class="n">v1</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">f1</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v2</span>
<span class="n">f2</span> <span class="o">=</span> <span class="o">~</span><span class="n">v1</span> <span class="o">&amp;</span> <span class="n">v3</span>
<span class="n">f3</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">&amp;</span> <span class="n">v4</span>
<span class="n">f4</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">&amp;</span> <span class="n">v3</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">|</span> <span class="n">v2</span> <span class="o">|</span> <span class="n">v3</span> <span class="o">|</span> <span class="n">v4</span> <span class="c1"># BoolFunc.make_or(4) と等価</span>

<span class="n">ifunc_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">]</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">ifunc_list</span><span class="p">)</span>

<span class="c1"># 結果は (v1 &amp; ~v2) | (~v1 &amp; v3) | (v2 &amp; v4) | (v1 &amp; v3)</span>
<span class="c1"># と等価になる．</span>
</pre></div>
</div>
</section>
<section id="id4">
<h3>情報の取得<a class="headerlink" href="#id4" title="この見出しへのパーマリンク">¶</a></h3>
<p>論理関数に関する情報を取得するメソッドは以下の通り．</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>関数名</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>input_num</p></td>
<td><p>入力数を返す．&#64;property</p></td>
</tr>
<tr class="row-odd"><td><p>val(ival_list)</p></td>
<td><p>入力値に対する関数値を返す．
ival_list は入力値のリスト</p></td>
</tr>
<tr class="row-even"><td><p>gen_minterm_list()</p></td>
<td><p>on-set, dc-set, off-set
を表す最小項のリストを返す．
結果は Cube の list の tuple</p></td>
</tr>
<tr class="row-odd"><td><p>gen_primes()</p></td>
<td><p>主項(prime implicants) のリスト
を返す．主項は <cite>Cube</cite> で表される．</p></td>
</tr>
<tr class="row-even"><td><p>gen_minimum_cover()</p></td>
<td><p>最簡積和形のリストを返す．
結果は <cite>Cover</cite> のリストとなる．</p></td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lctools</span> <span class="kn">import</span> <span class="n">BoolFunc</span>

<span class="n">INPUT_NUM</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">x4</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="n">INPUT_NUM</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">&amp;</span> <span class="n">x2</span> <span class="o">|</span> <span class="o">~</span><span class="n">x3</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">x4</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">input_num</span><span class="p">)</span> <span class="c1"># 4 が出力される．</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">val</span><span class="p">([</span><span class="n">Bool3</span><span class="o">.</span><span class="n">_0</span><span class="p">,</span> <span class="n">Bool3</span><span class="o">.</span><span class="n">_0</span><span class="p">,</span> <span class="n">Bool3</span><span class="o">.</span><span class="n">_0</span><span class="p">,</span> <span class="n">Bool3</span><span class="o">.</span><span class="n">_0</span><span class="p">]))</span> <span class="c1"># Bool3._1が出力される．</span>
</pre></div>
</div>
</section>
<section id="id5">
<h3>内容の出力<a class="headerlink" href="#id5" title="この見出しへのパーマリンク">¶</a></h3>
<p>論理関数の内容を出力するメソッドは以下の通り．</p>
<table class="docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>関数名</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>print_table()</p></td>
<td><p>内容を真理値表の形式で出力する．</p></td>
</tr>
<tr class="row-odd"><td><p>print_karnaugh()</p></td>
<td><p>内容をかるノーズの形式で出力する．</p></td>
</tr>
<tr class="row-even"><td><p>gen_latex_minterm_sop()</p></td>
<td><p>積和標準形をLaTeX形式で出力する．</p></td>
</tr>
<tr class="row-odd"><td><p>gen_latex_maxterm_pos()</p></td>
<td><p>和積標準形をLaTeX形式で出力する．</p></td>
</tr>
<tr class="row-even"><td><p>gen_latex_table(fname)</p></td>
<td><p>真理値表をLaTeX形式で出力する．
真理値表の右上に表示される関数名を
fname で指定する．</p></td>
</tr>
<tr class="row-odd"><td><p>gen_latex_tables(func_list, fname_list)</p></td>
<td><p>複数の関数をまとめた真理値表をLaTeX形式で
出力する．&#64;staticmethod</p></td>
</tr>
<tr class="row-even"><td><p>gen_latex_karnaugh(implicant_list=None)</p></td>
<td><p>カルノー図をLaTeX形式で出力する．
LaTeX側で <cite>karnaugh.sty</cite>
を用いる必要がある．
implicant_list に <cite>Cube</cite> のリストを与えると
カルノー図上で積項を表示するようになる．</p></td>
</tr>
<tr class="row-odd"><td><p>gen_dpic_hypercube()</p></td>
<td><p>幾何学表現用のLaTeXソースを出力する．
正確には dpic 用のm4マクロを出力する．</p></td>
</tr>
</tbody>
</table>
<p>これらの関数はすべて名前付きのオプション引数として <cite>var_map</cite> および
<cite>fout</cite> を受け取る．
<cite>var_map</cite> には変数番号をキーにして変数名を納めた辞書を与える．
省略時には <cite>BoolFunc</cite> オブジェクト固有の var_map を用いる．
<cite>fout</cite> には出力先のファイルオブジェクトを与える．
省略時には標準出力が用いられる．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lctools</span> <span class="kn">import</span> <span class="n">BoolFunc</span>

<span class="n">v1</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">BoolFunc</span><span class="o">.</span><span class="n">make_literal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">v1</span> <span class="o">&amp;</span> <span class="n">v3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&amp;</span> <span class="n">v4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&amp;</span> <span class="n">v3</span><span class="p">)</span>
</pre></div>
</div>
<p>この <cite>f</cite> に対する出力結果を以下に示す．
なお，デフォルトの <cite>var_map</cite> は以下のようになっている．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var_map</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;x_1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;x_2&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;x_3&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;x_4&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>この変数名を LaTeX で出力する場合，自動的に数式モードで処理されるため，
<img class="math" src="_images/math/5ea99039cd8359fa2e14317dbfae4497ebbc1360.png" alt="x_1"/> のように下付き文字となる．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">print_table</span><span class="p">()</span>
</pre></div>
</div>
<p>出力結果</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> x_1 x_2 x_3 x_4| f
----------------+--
  0   0   0   0 | 0
  0   0   0   1 | 0
  0   0   1   0 | 1
  0   0   1   1 | 1
  0   1   0   0 | 0
  0   1   0   1 | 1
  0   1   1   0 | 1
  0   1   1   1 | 1
  1   0   0   0 | 1
  1   0   0   1 | 1
  1   0   1   0 | 1
  1   0   1   1 | 1
  1   1   0   0 | 0
  1   1   0   1 | 1
  1   1   1   0 | 1
  1   1   1   1 | 1
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">print_karnaugh</span><span class="p">()</span>
</pre></div>
</div>
<p>出力結果</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> x_3x_4|00|01|11|10|
   \   |  |  |  |  |
 x_1x_2|  |  |  |  |
-------+--+--+--+--+
  00   | 0| 0| 1| 1|
-------+--+--+--+--+
  01   | 0| 1| 1| 1|
-------+--+--+--+--+
  11   | 0| 1| 1| 1|
-------+--+--+--+--+
  10   | 1| 1| 1| 1|
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">gen_latex_minterm_sop</span><span class="p">()</span>
</pre></div>
</div>
<p>LaTeXの出力結果</p>
<div class="math">
<p><img src="_images/math/d607876eb1046df8ffec35762355995299557e75.png" alt="\bar{x_1}\bar{x_2}x_3\bar{x_4} + \bar{x_1}\bar{x_2}x_3x_4 + \bar{x_1}x_2\bar{x_3}x_4 + \bar{x_1}x_2x_3\bar{x_4} + \bar{x_1}x_2x_3x_4 + x_1\bar{x_2}\bar{x_3}\bar{x_4} + x_1\bar{x_2}\bar{x_3}x_4 + x_1\bar{x_2}x_3\bar{x_4} + x_1\bar{x_2}x_3x_4 + x_1x_2\bar{x_3}x_4 + x_1x_2x_3\bar{x_4} + x_1x_2x_3x_4"/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">gen_latex_maxterm_pos</span><span class="p">()</span>
</pre></div>
</div>
<p>LaTeXの出力結果</p>
<div class="math">
<p><img src="_images/math/fa67b4db93273083b8ed08920fdca091deedca20.png" alt="(x_1 + x_2 + x_3 + x_4)(x_1 + x_2 + x_3 + \bar{x_4})(x_1 + \bar{x_2} + x_3 + x_4)(\bar{x_1} + \bar{x_2} + x_3 + x_4)"/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">gen_latex_table</span><span class="p">(</span><span class="s1">&#39;f_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>LaTeXの出力結果</p>
<div class="math">
<p><img src="_images/math/01208536d9d423d9754aa3e465cad8515548cf31.png" alt="\begin{tabular}{|cccc|c|}
\hline
$x_1$ &amp; $x_2$ &amp; $x_3$ &amp; $x_4$ &amp;  $f_1$\\
\hline \hline
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\
1 &amp; 1 &amp; 1 &amp; 0 &amp; 1\\
1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\
\hline
\end{tabular}"/></p>
</div><p><cite>gen_latex_table()</cite> に与える関数名はLaTeXソース中では <cite>$</cite>
で囲まれているのでLaTeXの数式モードで使用可能な記法を使うことができる．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="o">~</span><span class="n">f</span>

<span class="n">BoolFunc</span><span class="o">.</span><span class="n">gen_latex_tables</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>LaTeXの出力結果</p>
<div class="math">
<p><img src="_images/math/2eb19ec68950169f63bde4647548a84970028ff0.png" alt="\begin{tabular}{|cccc|cc|}
\hline
$x_1$ &amp; $x_2$ &amp; $x_3$ &amp; $x_4$ &amp;  $f$ &amp;  $g$\\
\hline \hline
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\
1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\
\hline
\end{tabular}"/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">gen_latex_karnaugh</span><span class="p">()</span>
</pre></div>
</div>
<p>LaTeXの出力結果</p>
<img alt="_images/karnaugh.jpg" class="align-center" src="_images/karnaugh.jpg" />
<p>この出力を得るためにはLaTeX側のプリアンブルに
<cite>\usepackage{karnaugh-map}</cite> の記述を加える必要がある．</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">gen_dpic_hypercube</span><span class="p">()</span>
</pre></div>
</div>
<p>出力結果</p>
<img alt="_images/hypercube.jpg" class="align-center" src="_images/hypercube.jpg" />
<p>この関数の出力するファイルの形式はm4マクロと呼ばれる
マクロプリプロセッサのソースファイルで，
<cite>circuit_macros</cite> と呼ばれる回路図描画用のマクロライブラリ
を適用した後で <cite>dpic</cite> と呼ばれるプログラムで LaTeX 用の
描画形式(Tikz/PGF)に変換する．
最後にLaTeXで画像生成を行っている．</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">論理関数に関する処理</a><ul>
<li><a class="reference internal" href="#bool3">論理値(Bool3)</a></li>
<li><a class="reference internal" href="#boolfunc">論理関数(BoolFunc)</a><ul>
<li><a class="reference internal" href="#id2">BoolFuncの生成</a></li>
<li><a class="reference internal" href="#id3">論理演算</a></li>
<li><a class="reference internal" href="#id4">情報の取得</a></li>
<li><a class="reference internal" href="#id5">内容の出力</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="index.html"
                          title="前の章へ">LogicTools: 論理回路の学習用ツール</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="sop_tutorial.html"
                          title="次の章へ">積和形論理式に関する処理</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/function_tutorial.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="sop_tutorial.html" title="積和形論理式に関する処理"
             >次へ</a> |</li>
        <li class="right" >
          <a href="index.html" title="LogicTools: 論理回路の学習用ツール"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">logictools 1.0 ドキュメント</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">論理関数に関する処理</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Yusuke Matsunaga(松永 裕介).
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>
  </body>
</html>